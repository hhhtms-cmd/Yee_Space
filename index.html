<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yee's Photo Particle Space</title>
    <style>
        :root { --accent-color: #00ffaa; --bg-color: #050505; }
        body { margin: 0; background: var(--bg-color); overflow: hidden; color: white; font-family: "PingFang SC", sans-serif; }
        
        /* 1. åˆå§‹ Key è¾“å…¥ */
        #welcome-screen { position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #api-key-input { background: rgba(255,255,255,0.1); border: 1px solid #333; color: white; padding: 12px; width: 300px; border-radius: 8px; text-align: center; margin-bottom: 20px; outline: none; }
        #start-btn { padding: 10px 40px; border-radius: 20px; background: var(--accent-color); color: black; border: none; font-weight: bold; cursor: pointer; }

        /* 2. ä¸Šä¼ æŒ‰é’®æ ·å¼ (ä»¿ç…§æˆªå›¾) */
        #upload-container { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 100; text-align: center; }
        .upload-label { background: rgba(255,255,255,0.1); border: 1px dashed rgba(255,255,255,0.3); padding: 8px 20px; border-radius: 20px; cursor: pointer; font-size: 12px; transition: 0.3s; }
        .upload-label:hover { background: rgba(255,255,255,0.2); border-color: var(--accent-color); }
        #file-input { display: none; }

        /* 3. ä¸» UI */
        nav { position: absolute; top: 0; width: 100%; padding: 20px 40px; display: flex; justify-content: space-between; font-size: 12px; letter-spacing: 2px; z-index: 10; opacity: 0.6; }
        #chat-area { position: absolute; top: 150px; width: 100%; text-align: center; z-index: 5; padding: 0 20px; box-sizing: border-box; }
        #ai-reply { font-size: 18px; font-weight: 300; margin-bottom: 10px; text-shadow: 0 0 10px rgba(0,0,0,0.8); }
        
        #controls { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; z-index: 20; }
        #mic-btn { width: 60px; height: 60px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.05); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; transition: 0.3s; }
        #mic-btn.active { border-color: #ff4444; box-shadow: 0 0 20px #ff4444; }

        /* 4. ç»“æœå¡ç‰‡ */
        #overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(15px); }
        .card { width: 280px; padding: 40px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 30px; text-align: center; }
    </style>
</head>
<body>

    <div id="welcome-screen">
        <h2 style="font-weight: 200; letter-spacing: 4px;">YEE'S SPACE</h2>
        <input type="text" id="api-key-input" placeholder="Paste Gemini API Key Here">
        <button id="start-btn">ENTER SPACE</button>
    </div>

    <div id="upload-container">
        <label for="file-input" class="upload-label">ğŸ“¸ UPLOAD PHOTO TO PARTICLE</label>
        <input type="file" id="file-input" accept="image/*">
    </div>

    <nav>
        <div>YEE'S MEMORY</div>
        <div>GEMINI PRO</div>
    </nav>

    <div id="chat-area">
        <div id="ai-reply">ä½ å¥½ Yeeï¼Œä¸Šä¼ ä¸€å¼ ç…§ç‰‡ï¼Œè®©æˆ‘ä»¬å¼€å§‹è®°å¿†æ—…ç¨‹ã€‚</div>
        <div id="user-speech" style="color: rgba(255,255,255,0.4); font-size: 14px;"></div>
    </div>

    <div id="controls">
        <div id="mic-btn">ğŸ™ï¸</div>
        <button id="save-btn" style="margin-top:20px; background:none; border:1px solid #444; color:white; padding:8px 15px; border-radius:15px; font-size:10px; cursor:pointer;">SAVE MEMORY</button>
    </div>

    <div id="overlay" onclick="this.style.display='none'">
        <div class="card">
            <div id="summary-text" style="line-height:1.8;">æ­£åœ¨ç”Ÿæˆæ€»ç»“...</div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let API_KEY = "";
        let scene, camera, renderer, particles, geometry;
        let audioContext, analyser, dataArray, isAudioReady = false;
        let conversationHistory = [];

        // --- 1. åˆå§‹åŒ–ç¯å¢ƒ ---
        document.getElementById('start-btn').onclick = () => {
            const key = document.getElementById('api-key-input').value.trim();
            if(key.length < 10) return alert("Please enter valid Key");
            API_KEY = key;
            document.getElementById('welcome-screen').style.display = 'none';
            initThree();
            initAudio();
        };

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 15;
            animate();
        }

        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isAudioReady = true;
            } catch(e) { console.warn("Mic not available"); }
        }

        // --- 2. å›¾ç‰‡è½¬ç²’å­æ ¸å¿ƒé€»è¾‘ ---
        document.getElementById('file-input').onchange = function(e) {
            const file = e.target.files[0];
            if(!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    createParticlesFromImage(img);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        function createParticlesFromImage(img) {
            // æ¸…é™¤æ—§ç²’å­
            if(particles) scene.remove(particles);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // ä¸ºäº†æ€§èƒ½ï¼Œå°†å›¾ç‰‡å‹ç¼©åˆ° 120x120 çš„é‡‡æ ·ç‚¹
            const size = 120;
            canvas.width = size;
            canvas.height = size;
            ctx.drawImage(img, 0, 0, size, size);
            
            const imgData = ctx.getImageData(0, 0, size, size).data;
            const positions = [];
            const colors = [];

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    const r = imgData[i] / 255;
                    const g = imgData[i+1] / 255;
                    const b = imgData[i+2] / 255;
                    const a = imgData[i+3] / 255;

                    if(a > 0.1) { // è¿‡æ»¤é€æ˜åƒç´ 
                        // å±…ä¸­åæ ‡
                        positions.push((x - size/2) * 0.12, -(y - size/2) * 0.12, 0);
                        colors.push(r, g, b);
                    }
                }
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.07,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            document.getElementById('ai-reply').innerText = "å›¾ç‰‡å·²å‡ç»“ä¸ºè®°å¿†ç²’å­ã€‚";
        }

        // --- 3. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            let vol = 0;
            if(isAudioReady && analyser) {
                analyser.getByteFrequencyData(dataArray);
                vol = dataArray.reduce((a, b) => a + b) / dataArray.length;
            }

            if(particles) {
                const posArr = geometry.attributes.position.array;
                const time = performance.now() * 0.002;
                for (let i = 0; i < posArr.length; i += 3) {
                    // ç²’å­éšæ­£å¼¦æ³¢å’Œå£°éŸ³èµ·ä¼
                    const wave = Math.sin(time + posArr[i] * 0.5);
                    posArr[i + 2] = wave * (0.2 + vol * 0.03); 
                }
                geometry.attributes.position.needsUpdate = true;
                particles.rotation.y += 0.001; // ç¼“æ…¢è‡ªè½¬
            }
            renderer.render(scene, camera);
        }

        // --- 4. è¯­éŸ³/èŠå¤©äº¤äº’ ---
        async function runChat(text) {
            if(!text) return;
            conversationHistory.push({ role: "user", parts: [{ text: text }] });
            document.getElementById('ai-reply').innerText = "Thinking...";

            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: conversationHistory })
                });
                const data = await res.json();
                const reply = data.candidates[0].content.parts[0].text;
                document.getElementById('ai-reply').innerText = reply;
                conversationHistory.push({ role: "model", parts: [{ text: reply }] });
            } catch (e) { document.getElementById('ai-reply').innerText = "API è¿æ¥å¤±è´¥"; }
        }

        // è¯­éŸ³è¯†åˆ«è®¾ç½®
        const Speech = window.SpeechRecognition || window.webkitSpeechRecognition;
        if(Speech) {
            const rec = new Speech();
            rec.lang = 'zh-CN';
            document.getElementById('mic-btn').onclick = () => {
                rec.start();
                document.getElementById('mic-btn').classList.add('active');
            };
            rec.onresult = (e) => {
                const t = e.results[0][0].transcript;
                document.getElementById('user-speech').innerText = `â€œ ${t} â€`;
                runChat(t);
            };
            rec.onend = () => document.getElementById('mic-btn').classList.remove('active');
        }

        // ç”Ÿæˆæ€»ç»“å¡ç‰‡
        document.getElementById('save-btn').onclick = async () => {
            document.getElementById('overlay').style.display = 'flex';
            if(conversationHistory.length === 0) {
                document.getElementById('summary-text').innerText = "è¿˜æ²¡æœ‰å¯¹è¯è®°å½•ã€‚";
                return;
            }
            const prompt = "æ€»ç»“æˆ‘ä»¬çš„å¯¹è¯ï¼Œå†™ä¸€æ®µè¯—æ„çš„æ„Ÿæ‚Ÿï¼Œ30å­—ä»¥å†…ã€‚";
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [...conversationHistory, { role:"user", parts:[{text:prompt}]}] })
                });
                const data = await res.json();
                document.getElementById('summary-text').innerText = data.candidates[0].content.parts[0].text;
            } catch(e) { document.getElementById('summary-text').innerText = "æ„Ÿæ‚Ÿç”Ÿæˆå¤±è´¥"; }
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
